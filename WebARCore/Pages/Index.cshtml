@page
@model IndexModel
@{
    ViewData["Title"] = "Home page";
}

<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Unity Web Player | ImageToAnime</title>
    <link rel="shortcut icon" href="TemplateData/favicon.ico">
    <link rel="stylesheet" href="TemplateData/style.css">
    <link rel="stylesheet" href="TemplateData/RecordingButton.css">



    <style>
    .record-btn {
        background-color: transparent;
        border: 2px solid #fff;
        border-radius: 50%;
        color: #fff;
        display: inline-block;
        height: 60px;
        width: 60px;
        position: fixed; 
        bottom: 20px; 
        left: 50%;
        transform: translateX(-50%);
        cursor: pointer;
        text-align: center;
        line-height: 56px;
        font-size: 24px;
        transition: background-color 0.3s, color 0.3s;
    }

    .record-btn.recording {
        
        color: red;
    }
    button {
      margin: 0 3px 10px 0;
      padding-left: 2px;
      padding-right: 2px;
      width: 99px;
    }

    button:last-of-type {
      margin: 0;
    }

    p.borderBelow {
      margin: 0 0 20px 0;
      padding: 0 0 20px 0;
    }

    video {
      height: 232px;
      margin: 0 12px 20px 0;
      vertical-align: top;
      width: calc(20em - 10px);
    }

    video:last-of-type {
      margin: 0 0 20px 0;
    }

    video#gumVideo {
      margin: 0 20px 20px 0;
    }

      video#gumVideo {
        margin: 0 10px 10px 0;
      }
    }

    .buttons {
        margin-top: 10px;
    }
    .share-btn {
        margin-right: 5px;
    }

    </style>
</head>
<body>
    <video id="recorded" autoplay loop playsinline style="display: none;"></video>
    <div>
            @*<button id="record" class="record-btn">●</button>*@
            <button id="newrecord">New Record</button>
            @*<button id="play" disabled>Play</button>*@
            <button id="download" disabled>Download</button>
            <button class="share-btn" id="share">Share</button>
        </div>

    <div id="unity-container" style="width: 100%; height: 100%"  class="unity-desktop">
        <canvas id="unity-canvas" width=auto height=auto tabindex="-1"></canvas>

        <div id="record" class="recorder-container">
              <input type="checkbox" id="btn"/>
              <label  for="btn"></label>
        </div>

        
        <div id="unity-loading-bar">
            <div id="unity-logo"></div>
            <div id="unity-progress-bar-empty">
                <div id="unity-progress-bar-full"></div>
            </div>
        </div>

        <div id="unity-warning"> </div>
    </div>


    <script src="https://cdn.jsdelivr.net/npm/&#64;ffmpeg/ffmpeg&#64;0.10.0/dist/ffmpeg.min.js"></script>
    <script>
        //const { createFFmpeg, fetchFile } = FFmpeg;
        //const ffmpeg = createFFmpeg({ log: true });

        var mediaSource = new MediaSource();
        mediaSource.addEventListener('sourceopen', handleSourceOpen, false);
        var mediaRecorder;
        var recordedBlobs;
        var sourceBuffer;

        



        var recordedVideo = document.querySelector('video#recorded');

        var recordButton = document.querySelector('#btn');
        //var playButton = document.querySelector('button#play');
        var hideBtn = document.querySelector('button#hide');

        var downloadButton = document.querySelector('button#download');
        let isRecording = false;



         recordButton.addEventListener('change', toggleRecording);


        //playButton.onclick = play;
        downloadButton.onclick = download;
        newrecord.onclick = ShowWindownUnity;

        //console.log('location.host:', location.host);


        // window.isSecureContext could be used for Chrome
        var isSecureOrigin = location.protocol === 'https:' ||
          location.host.includes('localhost');
        if (!isSecureOrigin) {
          alert('getUserMedia() must be run from a secure origin: HTTPS or localhost.' +
            '\n\nChanging protocol to HTTPS');
          location.protocol = 'HTTPS';
        }

        var constraints = {
          audio: true,
          video: true
        };

        navigator.mediaDevices.getUserMedia(
          constraints
        ).then(
          successCallback,
          errorCallback
        );

        function successCallback(stream) {
          console.log('getUserMedia() got stream: ', stream);
          window.stream = stream;
          //gumVideo.srcObject = stream;
        }

        function errorCallback(error) {
          console.log('navigator.getUserMedia error: ', error);
        }

        function handleSourceOpen(event) {
          console.log('MediaSource opened');
          sourceBuffer = mediaSource.addSourceBuffer('video/webm; codecs="vp8"');
          console.log('Source buffer: ', sourceBuffer);
        }

        let previousTime = Date.now();

        function handleDataAvailable(event) {
          const timeNow = Date.now();
          console.log(`Interval: ${timeNow - previousTime}`);
          previousTime = timeNow;
          if (event.data && event.data.size > 0) {
            recordedBlobs.push(event.data);
          }
        }

        function handleStop(event) {
          console.log('Recorder stopped: ', event);
          console.log('Recorded Blobs: ', recordedBlobs);
        }

         function toggleRecording() {
            isRecording = recordButton.checked;;
            if (isRecording) {
                startRecording();
                return;
                console.log(isRecording);
            } else {
                stopRecording();
                console.log(isRecording);

                //playButton.disabled = false;
                downloadButton.disabled = false;
                return;
            }
        }

        // The nested try blocks will be simplified when Chrome 47 moves to Stable
        function startRecording() {
            //if (MediaRecorder.isTypeSupported('video/webm\;codecs=h264')) {
            //// only on Chrome
            //    var recorder = RecordRTC(stream, {
            //    mimeType: 'video/webm\;codecs=h264'
            //});


          var options = {mimeType: 'video/webm\;codecs=h264'};
          recordedBlobs = [];
          try {
            mediaRecorder = new MediaRecorder(window.stream, options);
          } catch (e0) {
            console.log('Unable to create MediaRecorder with options Object: ', options, e0);
            try {
              options = {mimeType: 'video/webm\;codecs=h264'};
              mediaRecorder = new MediaRecorder(window.stream, options);
            } catch (e1) {
              console.log('Unable to create MediaRecorder with options Object: ', options, e1);
              try {
                mediaRecorder = new MediaRecorder(window.stream);
              } catch (e2) {
                alert('MediaRecorder is not supported by this browser.');
                console.log('Unable to create MediaRecorder', e2);
                return;
              }
            }
          }
          console.log('Created MediaRecorder', mediaRecorder, 'with options', options);
          //recordButton.textContent = 'Stop Recording';
          //playButton.disabled = true;
          downloadButton.disabled = true;
          mediaRecorder.onstop = handleStop;
          mediaRecorder.ondataavailable = handleDataAvailable;
          mediaRecorder.start(1000); // collect 10ms of data
          console.log('MediaRecorder started', mediaRecorder);
        }


      


        function stopRecording() {
          mediaRecorder.stop();
          recordedVideo.controls = true;

          play();
        }
        

        function ShowWindownUnity()
        {
            $("#unity-container").show();
            HideWindownPlayVideoAndDownload();
        }

        function HideWindownUnity()
        {
            $("#unity-container").hide();
        }

        function ShowWindownPlayVideoAndDownload()
        {
            $("#recorded").show();
        }

        function HideWindownPlayVideoAndDownload()
        {
            $("#recorded").hide();
        }

        function play() {

          HideWindownUnity();
          ShowWindownPlayVideoAndDownload();

          var type = (recordedBlobs[0] || {}).type;
          var superBuffer = new Blob(recordedBlobs, {type});
          recordedVideo.src = window.URL.createObjectURL(superBuffer);
        }

        function download() {

          var blob = new Blob(recordedBlobs, {type: 'video/mp4'});
          var url = window.URL.createObjectURL(blob);
          var a = document.createElement('a');
          a.style.display = 'none';
          a.href = url;
          a.download = 'test.mp4';
          document.body.appendChild(a);
          a.click();
          setTimeout(function() {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
          }, 100);
        }

         document.getElementById('share').addEventListener('click',async function() {
            if (navigator.share) {
                try {
                  var blob = new Blob(recordedBlobs, { type: 'video/mp4' });
                  var file = new File([blob], 'video.mp4', { type: 'video/mp4' });
                  try{
                      await navigator.share({
                        //title: 'Check out this video',
                        //text: 'Here is a video I recorded.',
                        files: [file],
                      });
                  }catch(error){


                  }
                  
                  console.log('Content shared successfully');
                } catch (error) {
                  console.log('Error sharing content', error);
                }
              } else {
                console.log('Web Share API is not supported in this browser.');
              }
        });



        //async function download() {
        //    const mp4Blob = await convertWebMToMP4(new Blob(recordedBlobs, { type: 'video/webm' }));
        //    const url = window.URL.createObjectURL(mp4Blob);
        //    const a = document.createElement('a');
        //    a.style.display = 'none';
        //    a.href = url;
        //    a.download = 'video.mp4';
        //    document.body.appendChild(a);
        //    a.click();
        //    setTimeout(() => {
        //        document.body.removeChild(a);
        //        window.URL.revokeObjectURL(url);
        //    }, 100);
        //}
    
        //async function convertWebMToMP4(webMBlob) {
        //    await ffmpeg.load();
        //    ffmpeg.FS('writeFile', 'input.webm', await fetchFile(webMBlob));
        //    await ffmpeg.run('-i', 'input.webm', 'output.mp4');
        //    const data = ffmpeg.FS('readFile', 'output.mp4');
        //    return new Blob([data.buffer], { type: 'video/mp4' });
        //}


        var canvas = document.querySelector("#unity-canvas");

        // Shows a temporary message banner/ribbon for a few seconds, or
        // a permanent error message on top of the canvas if type=='error'.
        // If type=='warning', a yellow highlight color is used.
        // Modify or remove this function to customize the visually presented
        // way that non-critical warnings and error messages are presented to the
        // user.
        function unityShowBanner(msg, type) {
            var warningBanner = document.querySelector("#unity-warning");
            function updateBannerVisibility() {
                warningBanner.style.display = warningBanner.children.length ? 'block' : 'none';
            }
            var div = document.createElement('div');
            div.innerHTML = msg;
            warningBanner.appendChild(div);
            if (type == 'error') div.style = 'background: red; padding: 10px;';
            else {
                if (type == 'warning') div.style = 'background: yellow; padding: 10px;';
                setTimeout(function () {
                    warningBanner.removeChild(div);
                    updateBannerVisibility();
                }, 5000);
            }
            updateBannerVisibility();
        }

        var buildUrl = "Build";
        var loaderUrl = buildUrl + "/test.loader.js";
        var config = {
            arguments: [],
            dataUrl: buildUrl + "/test.data",
            frameworkUrl: buildUrl + "/test.framework.js",
            codeUrl: buildUrl + "/test.wasm",
            streamingAssetsUrl: "StreamingAssets",
            companyName: "DefaultCompany",
            productName: "ImageToAnime",
            productVersion: "0.1",
            showBanner: unityShowBanner,
        };

        // By default, Unity keeps WebGL canvas render target size matched with
        // the DOM size of the canvas element (scaled by window.devicePixelRatio)
        // Set this to false if you want to decouple this synchronization from
        // happening inside the engine, and you would instead like to size up
        // the canvas DOM size and WebGL render target sizes yourself.
        // config.matchWebGLToCanvasSize = false;

        //if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        //    // Mobile device style: fill the whole browser client area with the game canvas:

        //    var meta = document.createElement('meta');
        //    meta.name = 'viewport';
        //    meta.content = 'width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes';
        //    document.getElementsByTagName('head')[0].appendChild(meta);
        //    document.querySelector("#unity-container").className = "unity-mobile";
        //    canvas.className = "unity-mobile";

        //    // To lower canvas resolution on mobile devices to gain some
        //    // performance, uncomment the following line:
        //    // config.devicePixelRatio = 1;


        //} else {

            // Desktop style: Render the game canvas in a window that can be maximized to fullscreen:
            canvas.style.width = "100%";
            canvas.style.height = "100%";
        //}

        document.querySelector("#unity-loading-bar").style.display = "block";

        var script = document.createElement("script");
        script.src = loaderUrl;
        script.onload = () => {
            createUnityInstance(canvas, config, (progress) => {
                document.querySelector("#unity-progress-bar-full").style.width = 100 * progress + "%";
            }).then((unityInstance) => {
                document.querySelector("#unity-loading-bar").style.display = "none";
                //document.querySelector("#unity-fullscreen-button").onclick = () => {
                //    unityInstance.SetFullscreen(1);
                //};

            }).catch((message) => {
                alert(message);
            });
        };

        document.body.appendChild(script);


        
        // Share functions
       

        //document.getElementById('share-twitter').addEventListener('click', function() {
        //    shareVideo('twitter');
        //});

        //document.getElementById('share-linkedin').addEventListener('click', function() {
        //    shareVideo('linkedin');
        //});

        //async function shareVideo(platform) {

        //    const mp4Blob = await convertWebMToMP4(new Blob(recordedBlobs, { type: 'video/webm' }));
        //    const url = window.URL.createObjectURL(mp4Blob);
        //    //var blob = new Blob(recordedBlobs, { type: 'video/webm' });
        //    //var url
        //    //var url = window.URL.createObjectURL(blob);
        //    var shareUrl;
           

        //    switch(platform) {
        //        case 'facebook':
        //            shareUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(url)}`;
        //            break;
        //        case 'twitter':
        //            shareUrl = `https://twitter.com/intent/tweet?url=${encodeURIComponent(url)}`;
        //            break;
        //        case 'linkedin':
        //            shareUrl = `https://www.linkedin.com/shareArticle?mini=true&url=${encodeURIComponent(url)}`;
        //            break;
        //        default:
        //            return;
        //    }

        //    window.open(shareUrl, '_blank');
        //}

    </script>


</body>
</html>

